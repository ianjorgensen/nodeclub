#!/usr/bin/env ruby

#############################################################################
#                                                                           #
# Duostack Command Line Client                                              #
#                                                                           #
# Copyright Â© 2011 Duostack, Inc. <http://duostack.com/>.                   #
#                                                                           #
# This program is free software: you can redistribute it and/or modify      #
# it under the terms of the GNU General Public License as published by      #
# the Free Software Foundation, either version 3 of the License, or         #
# (at your option) any later version.                                       #
#                                                                           #
# This program is distributed in the hope that it will be useful,           #
# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
# GNU General Public License for more details.                              #
#                                                                           #
# You should have received a copy of the GNU General Public License         #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.     #
#                                                                           #
#############################################################################

require 'cgi'
$dir = File.dirname(File.expand_path(__FILE__))
$client = File.basename(__FILE__)

module Duostack
  class Client
    
    VERSION = '0.5.0'
    DEPENDENCIES_LAST_MODIFIED = 1298683372
    USER_AGENT = "duostack-#{VERSION}"
    
    DEFAULTS = {
      :credentials_location => '~/.duostack',
      :remote_name => 'duostack',
      :console_type => 'app'
    }
    
    FLAGS = [                        # app and remote get special handling
      'confirm',
      'long',
      'skip-dependency-checks'
    ]
    
    COMMANDS = {
      :default => 'help',            # command used when no other command is given
      :general => %w(version help),  # general commands, can always be run
      :user    => [                  # commands requiring credentials (first-time setup)
        'create',
        'list',
        'sync',
        'billing_reset'
      ],
      :app     => [                  # commands requiring an app to be specified (either by git inference or flag)
        'info',
        'logs',
        'restart',
        'ps',
        'destroy',
        'console',
        'rake',
        'config',
        'env',
        'access',
        'domains',
        'instances'
      ],
      :compound => [                 # mult-part commands that expect subsequent arguments, must validate extra args on their own
        'help',
        'create',
        'console',
        'rake',
        'config',
        'env',
        'access',
        'domains',
        'instances'
      ]
    }
    
    CONSOLES = {
      :app => {
        :target => 'cli-console@duostack.net',
        :display_type => 'Ruby',
        :display_name_suffix => '',
        :prompt => '>> '
      },
      :mysql => {
        :target => 'cli-dbconsole@duostack.net',
        :display_type => 'database',
        :display_name_suffix => ' (mysql)',
        :prompt => 'mysql> '
      },
      :mongodb => {
        :target => 'cli-dbconsole@duostack.net',
        :display_type => 'database',
        :display_name_suffix => ' (mongodb)',
        :prompt => '> '
      },
      :redis => {
        :target => 'cli-dbconsole@duostack.net',
        :display_type => 'database',
        :display_name_suffix => ' (redis)',
        :prompt => 'redis> '
      }
    }
    
    
    def initialize(args=[], client='duostack')
      @args = args
      @client = client
    end
    
    def run
      @creds_file = get_flag_arg('creds')  || DEFAULTS[:credentials_location]
      @remote     = get_flag_arg('remote') || DEFAULTS[:remote_name]
      # get app from args if we can, otherwise it will be extracted from git remotes during require_app
      @app_name   = get_flag_arg('app')
      @flags      = parse_flags
      @command    = @args.shift || COMMANDS[:default]
      
      # we consider this run to be confirmed if the app name has been specified in the args and the --confirm flag is passed
      @confirmed = @app_name && @flags.include?('confirm')
      
      # make sure everything is in order
      check_dependencies unless @flags.include?('skip-dependency-checks')
      validate_args                                       # checks for extraneous args and valid command
      require_app if COMMANDS[:app].include?(@command)    # checks that user is set and app can be ID'd
      require_user if COMMANDS[:user].include?(@command)  # checks user credentials
      
      # everything checks out; time to rock and roll
      send(@command)
    end
    
    
    # argument processing methods
    #########################################################################
    
    # extracts and validates any argument starting with '--', indicating a flag
    def parse_flags
      
      # extract flags
      flags = @args.collect do |arg|
        arg[2..-1] if arg[0..1] == '--'
      end.compact
      
      # remove flags from args
      @args.delete_if { |arg| arg[0..1] == '--' }
      
      return flags
    end
    
    # ensures that the command and all extracted flags are what we expect, warns if they aren't
    def validate_args
      
      invalid = []
      invalid += [@command] - COMMANDS.values.flatten   # validate command
      invalid += @flags - FLAGS                          # validate flags
      
      # unless command is compound (expecting further args), any remaining args must be invalid
      invalid += @args unless COMMANDS[:compound].include?(@command)
      
      if invalid.any?
        exit_with("unrecognized argument: '#{invalid.first}', run '#{@client} help' for usage")
      end
    end
    
    def get_next_args(qty=0, message="missing required argument(s), run '#{@client} help'")
      next_args = @args.slice!(0, qty)
      
      # make sure we got as many args as the caller wanted
      exit_with message unless next_args.length == qty
      
      # de-arrayify if only one
      next_args = next_args.first if next_args.length == 1
      
      return next_args
    end
    
    # used to read flags followed by an argument (e.g. --app)
    # returns the arg following the flag of "name" or nil
    def get_flag_arg(flag)
      if flag_index = @args.index("--#{flag}")
        # slice out flag args so we don't re-use them later, returning second element
        # will be nil if no arg is passed after --flag; that's okay
        @args.slice!(flag_index, 2)[1]
      end
    end
    
    
    # validation methods
    #########################################################################
    
    def check_dependencies
      
      filename = File.expand_path(@creds_file)
      return if File.exist?(filename) && File.mtime(filename).to_i > DEPENDENCIES_LAST_MODIFIED
      
      # ruby
      if `which ruby`.empty? # how are we even here?
        exit_with "missing dependency, please install Ruby 1.8.6 or later"
      end
      
      # ruby >= 1.8.6
      if `ruby -v`.split[1].to_f < 1.8
        exit_with "missing dependency, please install Ruby 1.8.6 or later"
      end
      
      # git (any)
      if `which git`.empty?
        exit_with "missing dependency, please install Git"
      end
      
      # curl
      if `which curl`.empty?
        exit_with "missing dependency, please install curl (http://curl.haxx.se/download.html)"
      end
      
      # curl with --cacert flag (version >= 7.5)
      version = `curl -V`.split.select { |s| s =~ /^(\d+\.)?(\d+\.)?(\d+\.)?(\*|\d+)$/ }.first # http://stackoverflow.com/questions/82064/a-regex-for-version-number-parsing
      major, minor, patch = version.split('.').collect { |s| s.to_i } # split on dots and convert to ints
      major, minor, patch = [major, minor, patch].collect { |v| v ||= 0 } # default each to 0
      if major < 7 || (major == 7 && minor < 5)
        exit_with "missing dependency, curl 7.5 or later is required (you have #{version})"
      end
      
      
      # curl SSL
      # handled inside api_host method
      
      # touch .duostack so we know when deps were last checked (but don't create it if it doesn't exist)
      require 'fileutils'
      FileUtils.touch(filename) if File.exist?(filename)
      
    end
    
    # ensures the app can be identified from inspecting the git repo or command line args
    def require_app
      require_user # all app commands require a user
      @app_name ||= app_name_from_git_remotes
      unless @app_name
        exit_with "run this command from a Duostack app folder or pass an app name with the --app argument"
      end
      return @app_name
    end
    
    # ensures user credentials are cached
    def require_user
      @credentials ||= `cat #{@creds_file} 2>/dev/null`.chomp
      
      if @credentials.empty?
        ssh_key = require_ssh_key # all user commands require an SSH key
        
        puts "First-time Duostack client setup"
        print "Email: "
        username = $stdin.gets.chomp
        print "Password: "
        begin
          # http://stackoverflow.com/questions/133719/how-to-read-a-password-in-ruby
          system "stty -echo"
          password = $stdin.gets.chomp
          puts '' # clears the line after
        ensure
          system "stty echo" # this is important
        end
        
        username = CGI::escape(username)
        password = CGI::escape(password)
        ssh_key  = CGI::escape(ssh_key)
        
        api_token = api_get('get_token', "api_username=#{username}&api_password=#{password}&ssh_key=#{ssh_key}", 5)
        `echo 'api_username=#{username}&api_token=#{api_token}' > #{@creds_file}`
        `chmod 600 #{@creds_file}`
        @credentials = `cat #{@creds_file} 2>/dev/null`.chomp
        if @credentials.empty? || @credentials.length < 32 # at least the length of the token
          exit_with "error saving credentials file, please contact support@duostack.com"
        end
        puts "Completed initial setup... waiting for sync..."
        sleep 4 # TODO: Do a sync check here in the future, 4 secs is safe for now
        puts ""
      end
      
      return @credentials
    end
    
    def require_ssh_key
      keyfile = ssh_key_location
      @ssh_key ||= `cat #{keyfile}`.chomp if keyfile
      unless @ssh_key
        exit_with "an SSH key is required to run this command, please generate an SSH key and try again (http://docs.duostack.com/command-line-client#setup)"
      end
      return @ssh_key
    end
    
    def require_confirmation
      # NOTE: @confirmed is set above in 'run' so we can be assured the app_name came from the --app flag
      # if assessed confirmation here, the app could have been extracted from the git repo
      unless @confirmed
        exit_with "command requires confirmation, run again with '--confirm --app #{@app_name}'"
      end
    end
    
    
    # utility methods
    #########################################################################
    
    def process_crud_command(opts)
      
      # get action
      action = @args.shift || 'list'      # list is the default
      action = 'list'   if action == 'ls' # normalize shorthand for list
      action = 'remove' if action == 'rm' # normalize shorthand for remove
      
      # extract important things from opts, otherwise merge defaults
      resource  = opts[:resource]
      resources = "#{resource}s" # may eventually need a better pluralizer
      
      # default settings for opts. priority is:
      #  1. hash under each action (e.g. opts[:actions][:list][:param])
      #  2. general opts (e.g. opts[:param])
      #  3. generic defaults specified here (e.g. `resources`, the pluralized resource name)
      defaults = {
        :error_message     => opts[:error_message]    || "<#{resource}>",
        :param             => opts[:param]            || resources,
        :additional_params => opts[:additonal_params] || nil,
        :args_processor    => opts[:args_processor]   || lambda { |args| args }
      }
      
      # actions can be either a hash (containing action-specific options) or an array (accept the defaults)
      if opts[:actions].respond_to?(:keys)
        valid_actions = opts[:actions].keys.map { |x| x.to_s }
        opts = defaults.merge(opts[:actions][action.to_sym])
      else
        valid_actions = opts[:actions]
        opts = defaults.merge(opts)
      end
      
      
      # ensure action is valid
      unless valid_actions.include?(action)
        exit_with "invalid argument for '#{@command}', try #{sentencize(valid_actions)}"
      end
      
      # ensure we have an argument for add/remove actions which require it
      if %w(add remove).include?(action)
        # gather up and compose remaining args for add/remove operations
        argument = opts[:args_processor].call(@args).join(' ')
        @args.clear # clean up, since we processed every remaining arg
        
        # warn and exit unless we have an argument to pass
        if argument.empty?
          exit_with "'#{@command} #{action}' requires an argument, try '#{@command} #{action} #{opts[:error_message]}'"
        end
        
        # clean up argument
        argument = CGI::escape(argument)
      else
        # ensure we *don't* have any further arguments for list/clear which don't allow them
        unless @args.empty?
          exit_with("unrecognized argument: '#{@args.first}', run '#{@client} help #{@command}' for usage")
        end
      end
      
      # finally, process action
      case action
      when 'list'
        print api_get("list_#{resources}", opts[:additional_params])
      when 'add'
        puts api_get("add_#{resource}",    ["#{opts[:param]}=#{argument}", opts[:additional_params]].compact.join('&'))
      when 'remove'
        puts api_get("remove_#{resource}", ["#{opts[:param]}=#{argument}", opts[:additional_params]].compact.join('&'))
      when 'clear'
        require_confirmation
        puts api_get("clear_#{resources}", opts[:additional_params])
      end
    end
    
    
    # attempts to get the app name out of git remotes
    # if --remote is specified, it will use that assuming it's valid
    # if not, it will look for any remote name that references duostack.net
    def app_name_from_git_remotes
      remotes = `git remote -v 2>/dev/null`.split("\n")
      remotes.reject! { |line| line.split.last == '(fetch)' } # filter out fetch remotes (careful, does not exist in older git versions)
      
      # find url of remote of specified name
      valid_remotes = remotes.reject do |line|
        line.split.first != @remote
      end
      remote_url = valid_remotes.first.split[1] unless valid_remotes.empty?
      
      # correct url will be in the form "git@duostack.net:appname.git"
      # if remote of specified name is a duostack remote, set app_name
      if !remote_url.to_s.empty? && remote_url[0..16] == "git@duostack.net:" && remote_url[-4..-1] == ".git"
        app_name = remote_url[17..-5]
      else # the specified remote isn't for duostack; look for another (take first match)
        remotes.each do |line|
          result = line.scan(/git@duostack\.net:(\w+)\.git/)
          if result.length > 0 && result[0].length > 0
            app_name = result[0][0]
            remote_name = line.split.first
            warn_with "remote '#{@remote}' does not refer to Duostack, using remote '#{remote_name}' instead"
            break
          end
        end
      end
      
      return app_name ||= nil
    end
    
    def ssh_key_location
      if `file ~/.ssh/id_rsa.pub`[/text|key/]
        '~/.ssh/id_rsa.pub'
      elsif `file ~/.ssh/id_dsa.pub`[/text|key/]
        '~/.ssh/id_dsa.pub'
      elsif `file ~/.ssh/identity.pub`[/text|key/]
        '~/.ssh/identity.pub'
      else
        nil
      end
    end
    
    def ca_cert_location
      return @ca_cert_location if @ca_cert_location # easy memoization
      
      candidates = [
        File.join($dir, '..', 'vendor', 'duostack-startcom.pem'), # gem packages
        File.join($dir, '.duostack-startcom.pem')                 # npm, tgz packages
      ]
      
      candidates.each do |filename|
        if File.exist?(filename)
          @ca_cert_location = filename
          return filename
        end
      end
      
      # if we get to this point, the cert wasn't found
      warn_with "custom certificate authority file not present, using system CA bundle"
      return nil
    end
    
    def api_host
      @api_host ||= begin
        host = "https://duostack.duostack.net"
        if !`curl -V`[/SSL/]
          warn_with "WARNING! curl SSL support is missing, using insecure plaintext mode"
          host = "http://duostack.duostack.net"
        end
        if local = ENV['DSLOCAL']
          debug "internal development mode"
          local ||= "http://localhost:3000"
          host = local
        end
        host
      end
    end
    
    def api_get(endpoint, params=nil, timeout=20)
      
      # store previous request
      @previous_request = [endpoint, params, timeout]
      
      url = "#{api_host}/api/#{endpoint}?#{@credentials}"
      
      url += "&app_name=#{@app_name}" if @app_name
      url += "&#{params}" if params
      
      curl_get(url, timeout)
    end
    
    # just retries last api_get, optionally passing additional params
    def api_retry(params=nil)
      exit false if @previous_request.empty?
      
      # add in additional params
      if params
        if @previous_request[1]
          @previous_request[1] = "#{@previous_request[1]}&#{params}"
        else
          @previous_request[1] = params
        end
      end
      
      # retry
      api_get(*@previous_request)
    end
    
    def curl_get(url, timeout=nil)
      command = "curl -s -A '#{USER_AGENT}' -w '\n%{http_code}'" # use w flag to append http status code, set user-agent header
      command += " --cacert #{ca_cert_location}" if ca_cert_location # use our own certificate if present
      command += " -m #{timeout}" if timeout
      command += " -v" if ENV['DSDEBUG']
      command += " '#{url}'" # finally, the actual URL to curl
      
      debug command
      raw = `#{command}`
      debug raw
      
      # break apart the raw result and extract the HTTP status code, reassemble
      parts = raw.split("\n")
      status = parts.pop.to_i
      result = parts.join("\n")
      
      # if the code is 422, we should have a displayable error message, so display directly
      if status == 422
        exit_with result
      end
      
      if status == 402
        print result          # prints error message and prompt
        return verify_account # handles input and retrying
      end
      
      case (status / 100) # just get the class of status, e.g. any 4xx code will become 4
      when 2 # success, return result sans status code
        return result
      when 1, 3, 4, 5 # the server is doing something dumb (500 error, redirect, 404s)
        exit_with "Duostack API error, please try again or contact support@duostack.com"
      else
        exit_with "could not connect to Duostack API"
      end
    end
    
    def verify_account
      response = $stdin.gets.chomp.downcase
      
      # unless response is yes or blank (default yes), exit
      exit unless response == 'yes'
      
      api_retry("billing_confirmed=1")
    end
    
    def sentencize(array, conjunction='or')
      # http://stackoverflow.com/questions/2038787/join-array-contents-into-an-english-list
      case array.length
      when 0, 1
        array.first.to_s
      when 2
        "#{array.first} #{conjunction} #{array.last}"
      else
        "#{array[0..-2].join(', ')}, #{conjunction} #{array.last}"
      end
    end
    
    def debug(message)
      puts message if ENV['DSDEBUG']
    end
    
    def warn_with(message='error')
      warn "#{@client}: #{message}"
    end
    
    def exit_with(message=nil, code=false)
      warn_with message
      exit code
    end
    
    
    
    # command methods
    #########################################################################
    
    def version
      puts VERSION
    end
    
    def help
      if content = Help.read_section(@args.shift)
        puts content
      else
        exit_with "unrecognized help section, try '#{@client} help'"
      end 
    end
    
    def sync
      # empty method, just makes sure credentials are set
    end
    
    # internal method for testing, just resets the billing confirmation prompt
    def billing_reset
      puts api_get('test_reset_billing_verification')
    end
    
    def list
      puts api_get('list_apps')
    end
    
    
    def create
      
      # ensure new app name passed, clean up
      name = get_next_args(1, "app name is required, try '#{@client} create <appname>'")
      name = CGI::escape(name.downcase)
      
      # ensure git repo
      if `git status 2>&1`[/Not a git/]
        exit_with "current directory is not a Git repository, run 'git init' first"
      end
      
      # make sure we're not going to step on an existing git remote
      if `git remote`.chomp.split("\n").include?(@remote)
        exit_with "there is already a Git remote named '#{@remote}', please remove it or pass a \ndifferent name with the --remote argument"
      end
      
      # create, add remote
      puts api_get('create_app', "app_name=#{name}")
      `git remote add #{@remote} git@duostack.net:#{name}.git 2>/dev/null`
      puts "Git remote added, to push: 'git push #{@remote} master'"
    end
    
    
    def info
      puts api_get('get_info')
    end
    
    
    def logs
      puts api_get('get_logs')
    end
    
    
    def restart
      puts api_get('restart')
    end
    
    
    def ps
      puts api_get('get_instances')
    end
    
    
    def destroy
      require_confirmation
      
      # pull out remote name before we destroy
      remote = `git remote show duostack 2>/dev/null`
      
      # destroy!
      puts api_get("delete_app")
      
      # attempt to remove duostack git remote
      # only if "duostack" remote actually references this app's remote
      if !remote.empty? and remote.scan("git@duostack.net:#{@app_name}.git").length > 0
        `git remote rm duostack 2>/dev/null`
      end
    end
    
    
    def console
      # TODO: just use ruby expect lib
      
      # get console and ensure it's valid
      arg = (@args.shift || DEFAULTS[:console_type]).downcase
      console = CONSOLES.fetch(arg.to_sym) do |invalid_type|
        exit_with "invalid console type given ('#{invalid_type}'), try #{sentencize(CONSOLES.keys.collect { |k| k.to_s})}"
      end
      
      # take piped input first as command, fall back to using remaining command line args
      if $stdin.tty?
        console_command = @args.join(' ') unless @args.empty?
        @args.clear
      else
        console_command = ''
        $stdin.each_line { |line| console_command << line }
      end
      
      # we're finished processing args any remaning ones are invalid
      unless @args.empty?
        exit_with("unrecognized argument: '#{@args.first}', run '#{@client} help #{@command}' for usage")
      end
      
      # check for expect dependency
      if `which expect`.empty?
        exit_with "missing dependency, please install Expect (http://expect.sourceforge.net/)"
      end
      
      if console_command
        
        # generate console command filename
        timestamp = begin
          t = Time.now
          "#{t.to_i}.#{t.usec}"
        end
        console_command_file = File.join('/tmp', "ds-#{timestamp}.txt")
        
        # write console command to file
        file = File.new(console_command_file, 'w+')
        file.chmod(0600)
        file.write(console_command)
        file.close
        
        result = `#{$dir}/.duostack-console-expect '#{File.join($dir, $client)}' '#{arg}' '#{console[:prompt]}' '#{console_command_file}' '#{@app_name}'`
        
        # clean up command file
        File.delete(console_command_file)
        
        # munge results
        result = result.split("\r\n")
        start  = (result.index("#{console[:prompt]}")     || 0) + 2
        stop   = (result.index("#{console[:prompt]}exit") || 0) - 1
        result = result.slice(start..stop)
        
        # clean up ruby return value marker
        result[-1] = result[-1][3..-1] if arg == 'app'
        
        puts result.join("\r\n")
        
      else
        exec("#{$dir}/.duostack-expect '#{console[:target]}' 'Connecting to #{console[:display_type]} console for ' '#{@app_name}#{console[:display_name_suffix]}'")
      end
    end
    
    
    def rake
      
      # get command(s), if they exist (all remaining args), clean up
      command = @args.join(' ')
      command = CGI::escape(command)
      
      puts api_get('run_rake', "command=#{command}", 60)
    end
    
    
    def config
      
      name, value = @args.slice!(0,2)
      
      name  = CGI::escape(name) if name
      value = CGI::escape(value) if value
      
      if name # name provided, get/set config
        if value # value provided, set config
          puts api_get('option_set', "name=#{name}&val=#{value}")
        else # no value provided, get config
          puts api_get('option_get', "name=#{name}")
        end
      else # no name provided, get list
        puts api_get('option_list')
      end
    end
    
    
    def env
      process_crud_command({
        :resource => 'env',
        :actions => {
          :list => {
            :additional_params => "truncate=#{!@flags.include?('long')}"
          },
          :add => {
            :error_message => '<name>=<value>',
            :param => 'input',
            :args_processor => lambda { |args|
              # recompose strings and quote values because ruby strips out quotation marks in the args.
              args.collect do |arg|
                if arg.include?('=')
                  result = arg.split('=',2)
                  %Q(#{result[0]}="#{result[1].gsub('"', '\"')}")
                else
                  arg
                end
              end
            }
          },
          :remove => {
            :error_message => '<name>',
            :param => 'name'
          },
          :clear => {}
        }
      })
    end
    
    
    def access
      process_crud_command({
        :resource => 'collab',
        :param => 'emails',
        :error_message => '<email>',
        :actions => %w(list add)
      })
    end
    
    
    def domains
      process_crud_command({
        :resource => 'domain',
        :actions => %w(list add remove)
      })
    end
    
    def instances
      
      arg = @args.shift || 'show' # show is the default
      
      # instance only takes one arg so any remaning ones are invalid
      unless @args.empty?
        exit_with("unrecognized argument: '#{@args.first}', run '#{@client} help #{@command}' for usage")
      end
      
      action = if arg == 'show'
        :show
      else
        case arg[0..0]
        when '+' then :add
        when '-' then :remove
        else :set
        end
      end
      
      # process numerical argument unless listing
      if action != :show
        # drop the plus/minus sign to get qty (if add/remove)
        qty = if action == :set
          arg
        else
          arg[1..-1]
        end
      end
      
      # ensure qty is a plain integer at this point
      begin
        qty = Integer(qty)
      rescue ArgumentError # this is what Integer() throws if its arg isn't convertible to an int
        exit_with "'#{@command}' requires a numerical argument, try '#{@command} [+/-]<quantity>'"
      end
      
      
      # finally, process action
      case action
      when :show
        puts api_get("count_instances")
      when :add
        puts api_get("set_instances", "qty=#{qty}&type=inc")
      when :remove
        puts api_get("set_instances", "qty=#{qty}&type=dec")
      when :set
        puts api_get("set_instances", "qty=#{qty}")
      end
    end
    
    
    module Help
      
      # available help sections. first will be used as the default, so unshift 'help' into first position.
      SECTIONS = (COMMANDS[:general] + COMMANDS[:user] + COMMANDS[:app]).unshift('help')
      
      class << self
        
        def read_section(section)
          
          # use default if not set
          section ||= SECTIONS.first
          
          # validate section exists
          return false unless SECTIONS.include?(section)
          
          self.send(section).gsub(/\n\s{12}/, "\n") # strips leading spaces so we can keep these indented
        end
        
        def help
          <<-EOF
            
            Usage: #{$client} <command> [<args>] [--app <appname>] [--remote <remotename>]
            
            App commands must be either run from an app folder (a Git repository with a
            Duostack remote) or have the app specified with the "--app <appname>" flag. If
            both are present, the "--app" flag takes precedence.
            
            You can also use the "--remote" flag to set the app based on a specific Git 
            remote name. This is common when you run two Duostack Apps (e.g. staging and
            production) from the same folder. This flag can also be used when running 
            "create" to have the client set up a custom remote name (default is "duostack").
            
            The most common commands are listed below. For additional information on any of
            them, run: #{$client} help <command>
            
            General Commands:
              help [<command>]              Show this help, or detailed help on <command>
              create <appname>              Initialize a Git repository as a Duostack App
              list                          Show all apps associated with your account
              version                       Show version of this Duostack client
            
            App Commands:
              info                          Show app summary information
              logs                          Retrieve server logs
              restart                       Restart instances
              ps                            List instances with current status
              destroy                       Destroy Duostack App and associated data
              console [<type> [command]]    Connect to app or database console, run command
              config [<name> [<setting>]]   Show or set configuration options
              env [<operation>]             Manage environment variables
              access [<operation>]          Manage app collaborator access
              domains [<operation>]         Manage custom domains
              instances [<operation>]       Manage app instance count
            
            App Commands - Ruby:
              rake [<command>]              Run a Rake command
            
          EOF
        end
        
        def create
          <<-EOF
            
            Usage:
              #{$client} create <appname>
              #{$client} create <appname> --remote <remotename>
              
            Example:
              #{$client} create myappname
              #{$client} create myappname --remote staging
            
            Arguments:
              <appname>       A name for your app (restrictions apply, see below)
              <remotename>    An optional name for the created Git remote
            
            Creates a new Duostack App from the current directory with the given name.
            
            The current directory must be initialized as a Git repository (run 'git init').
            Upon running 'create', the app will be created on Duostack and a Git remote with
            the name 'duostack' will be added to the local repository, which you can push to
            to deploy your app: git push duostack master. If a custom remote name is
            specified with the '--remote' flag, that will be used instead.
            
            The app name must be 4-16 characters long, alphanumeric, and must not start with
            a number. The use of hyphens, underscores, or any other special characters is
            not supported.
            
          EOF
        end
        
        def list
          <<-EOF
            
            Usage: #{$client} list
            
            Shows a list of the apps associated with your Duostack account.
            
          EOF
        end
        
        def version
          <<-EOF
            
            Usage: #{$client} version
            
            Displays the client's version number.
            
          EOF
        end
        
        def info
          <<-EOF
            
            Usage: #{$client} info
            
            Retrieves a summary of app data, e.g. Git remote URL, instance count, etc.
            
          EOF
        end
        
        def logs
          <<-EOF
            
            Usage: #{$client} logs
            
            Retrieves aggregate logs from all of the app's instances.
            
          EOF
        end
        
        def restart
          <<-EOF
            
            Usage: #{$client} restart
            
            Restarts all of the app's instances. Useful for recovering from errors or
            forcing a purge of the HTTP cache for your app
            (see: http://docs.duostack.com/http-caching).
            
            This will also cause the app to pick up any changes to its configuration options
            or environment variables made with the 'config' or 'env' commands.
            
            Apps on Duostack are automatically restarted after each Git push deploy.
            
          EOF
        end
        
        def ps
          <<-EOF
            
            Usage: #{$client} ps
            
            Retrieves a listing of all of the app's instances with status information
            (uptime) for each.
            
          EOF
        end
        
        def destroy
          <<-EOF
            
            Usage: #{$client} destroy [--confirm]
            
            Destroys the app and all associated data. Can not be undone; use with caution.
            
            Requires confirmation.
            
          EOF
        end
        
        def config
          <<-EOF
            
            Usage:
              #{$client} config                       lists all configs and current settings
              #{$client} config <name>                shows valid settings for a config
              #{$client} config <name> <setting>      sets a setting for a config
            
            Examples:
              #{$client} config                       lists all configs and current settings
              #{$client} config stack                 shows valid settigns for "stack"
              #{$client} config stack ruby-mri-1.9.2  sets "stack" to "ruby-mri-1.9.2"
            
            Lists, shows, and sets app config options.
            
            List Configs: Shows a list of all available config option names with their
            current settings.
            
            Show Config: Shows a list of the valid settings for the config option <name>.
            <name> must be one of the available options shown in the list of configs. The
            currently selected value is denoted with an asterisk next to it.
            
            Set Config: Allows setting of config options. Sets config <name> to <setting>.
            <setting> must be one of the valid settings shown for this config.
            
          EOF
        end
        
        def env
          <<-EOF
            
            Usage:
              #{$client} env [--long]                 lists all env vars
              #{$client} env add <name>=<value>       adds env var <name> with <value>
              #{$client} env remove <name>            removes env var <name>
              #{$client} env clear [--confirm]        clears all env vars
            
            Examples:
              #{$client} env --long                   lists all env vars
              #{$client} env add API_KEY=AbO5m5fbrt   adds var API_KEY with value AbO5m5fbrt
              #{$client} env remove API_KEY           removes env var API_KEY
              #{$client} env clear --confirm          clears env vars
            
            Lists, adds, removes, and clears app environment variables.
            
            List: Lists environment variables currently set on the app. If none are set,
            output will be blank. List output is abbreviated by default for readability. If
            you need to see the full values of your environment variables, use the --long
            flag with this command.
            
            Add: Add one or more environment variables to the app. Add multiple by
            supplying additional <name>=<value> pairs separated by spaces. You may need to 
            quote any complex values (with spaces or special characters) that may confuse
            the client or your shell.
            
            Remove: Removes one or more environment variables from the app. Remove multiple
            by supplying additional variable <name> arguments separated by spaces.
            
            Clear: Clears all environment variables from the app. Requires confirmation.
            
          EOF
        end
        
        def access
          <<-EOF
            
            Usage:
              #{$client} access                          lists app collaborators
              #{$client} access add <email>              grants access for <email>
            
            Examples:
              #{$client} access                          lists app collaborators
              #{$client} access add name@example.com     grants access for name@example.com
            
            Lists and adds app collaborator access for users (identified by emails).
            
            List: Lists collaborator emails who currently have access to the app. If none
            are set, output will be blank.
            
            Add: Add one or more collaborators (by email address) to the app. Add multiple
            by supplying additional <email> arguments separated by spaces.
            
          EOF
        end
        
        def domains
          <<-EOF
            
            Usage:
              #{$client} domains                          lists all custom domains
              #{$client} domains add <domain>             adds <domain> as a custom domain
              #{$client} domains remove <domain>          removes custom domain <domain>
            
            Examples:
              #{$client} domains                          lists all env vars
              #{$client} domains add app.example.com      adds app.example.com to app
              #{$client} domains remove app.example.com   removes app.example.com from app
            
            Lists, adds, and removes custom domains
            (http://docs.duostack.com/custom-domains).
            
            List: Lists custom domains currently set on the app. If none are set, output
            will be blank.
            
            Add: Add one or more custom domains to the app. Add multiple by supplying
            additional <domain> arguments separated by spaces.
            
            Remove: Removes one or more custom domains from the app. Remove multiple by
            supplying additional <domain> arguments separated by spaces.
            
          EOF
        end
        
        def instances
          <<-EOF
            
            Usage:
              #{$client} instances                  shows current instance count
              #{$client} instances <qty>            sets instance count to <qty>
              #{$client} instances +<qty>           increments instance count by <qty> 
              #{$client} instances -<qty>           decrements instance count by <qty>
            
            Examples:
              #{$client} instances                  shows current instance count
              #{$client} instances 5                sets instance count to 5
              #{$client} instances +2               increments instance count by 2
              #{$client} instances -2               decrements instance count by 2
            
            Adjusts instance count, either setting absolutely, or incrementing/decrementing
            by a given quantity.
            
            Any increment, decrement, or set command that would result in an invalid 
            instance count will be rejected with an error message. Instance counts must be
            greater than 0.
            
          EOF
        end
        
        def console
          <<-EOF
            
            Usage:
              #{$client} console [<type> [<command>]]
                                           launches console session of <type> (defaults to
                                           'app' console), optionally runs specified
                                           <command> in console and prints the result
              
              #{$client} console <type> <command> > <output-file>
                                           pipes the output from running <command> to the
                                           specified <output-file>
              
              #{$client} console <type> < <input-file>
                                           pipes the contents of <input-file> into the
                                           specified console <type>, prints the result
            
            Examples:
              #{$client} console           same as running "#{$client} console app"
              #{$client} console app       launches interactive app console (Ruby apps only)
              #{$client} console mysql     launches interactive MySQL database console
              #{$client} console mongodb   launches interactive MongoDB database console
              #{$client} console redis     launches interactive Redis database console
              
              #{$client} console app "puts('hello world')"
              #{$client} console mysql "SHOW TABLES;"
                                           runs the specified command and prints the result
              
              #{$client} console mysql "SHOW TABLES;" > tables.txt
                                           runs "SHOW TABLES;" in the app's MySQL console,
                                           piping output into the file "tables.txt"
              
              #{$client} console mysql < import.sql
                                           (EXPERIMENTAL) pipes the contents of "import.sql"
                                           into the app's MySQL console, printing the result
            
            The "console" command can operate in three ways:
            
            1. Launching an interactive console session with your app or one of its
            databases. If no argument is given, it connects to the app console itself
            (applicable only to Ruby apps). If a database name is given, connects to a
            database console session for that database. Valid database names are: mysql,
            mongodb, redis.
            
            You can use then use these interactive console sessions to make any action you
            would normally make in your app or database console.
            
            2. Running an ad-hoc command specified on the command line in the remaining
            arguments, and printing the result. You could also then pipe the output into an
            arbitrary file.
            
            3. (EXPERIMENTAL) Sending the contents of a piped-in file to the specified (app
            or database) console. The resulting output will be collected and printed to your
            terminal.
            
          EOF
        end
        
        def rake
          <<-EOF
            
            Usage: #{$client} rake [<command>]
            
            Runs rake (with an optional <command> argument) on your app. After the task has
            run, the output will be displayed. Tasks running longer than 60 seconds will not
            have their full output displayed.
            
            Passing of environment variables if your rake task requires them is supported
            (e.g. rake db:seed MODEL=Posts).
            
            Applicable only to Ruby apps.
            
          EOF
        end
        
        
      end
    end
    
  end
end


Duostack::Client.new(ARGV.dup, $client).run
